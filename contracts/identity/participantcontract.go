package identity

import (
	"fmt"
	"strings"

	"github.com/hyperledger/fabric-contract-api-go/contractapi"
	lus "github.com/ic-matcom/cc-identity-go/lib-utils"
	model "github.com/ic-matcom/model-identity-go/model"
	modeltools "github.com/ic-matcom/model-identity-go/tools"
	"log"
)

// Config
// TODO: in a later version this configuration should be able to be managed in a decentralized way
type Config struct {
	AutogenerateDid bool `json:"autogenerateDid,omitempty" metadata:",optional"` // did is sent by the dapp, it is not generated by the chaincode
}

var config = Config{AutogenerateDid: false}

// InitLedger adds a base set of data to the ledger
func (ci *ContractIdentity) InitLedger(ctx contractapi.TransactionContextInterface) error {
	log.Printf("[%s][InitLedger]", ctx.GetStub().GetChannelID())
	// check if client-node is connected as admin
	if err := lus.AssertAdmin(ctx); err != nil {
		return fmt.Errorf(err.Error())
	}
	accessIdentity := model.AccessCreateRequest{
		ContractName:      ci.Name,                        // contract name
		ContractFunctions: modeltools.GetTransactions(ci), // functions name
	}

	// create identity access
	_, err := ci.CreateAccess(ctx, accessIdentity)
	if err != nil {
		return err
	}

	return nil
}

// CreateParticipant
func (ci *ContractIdentity) CreateParticipant(ctx contractapi.TransactionContextInterface, request model.ParticipantCreateRequest) (*model.ParticipantResponse, error) {
	log.Printf("[%s][CreateParticipant]", ctx.GetStub().GetChannelID())

	// check if client-node connected as admin
	if err := lus.AssertAdmin(ctx); err != nil {
		return nil, fmt.Errorf(err.Error())
	}

	// publicKey required
	if request.PublicKey == "" {
		return nil, fmt.Errorf(lus.ErrorRequiredParameter, "publicKey")
	}

	publicKey := request.PublicKey

	// Get MSP ID of the client
	clientMSPID, err := ctx.GetClientIdentity().GetMSPID()
	if err != nil {
		return nil, fmt.Errorf(lus.ErrorGetMSPID, err)
	}

	did := request.DID
	if config.AutogenerateDid {
		did, err = modeltools.CreateDid(request.PublicKey)
		if err != nil {
			return nil, err
		}
	} else if request.DID == "" {
		return nil, fmt.Errorf(lus.ErrorRequiredParameter, "did")
	}

	exist, err := ci.ParticipantExits(ctx, model.ParticipantGetRequest{Did: did})
	if err != nil {
		return nil, err
	}
	if exist {
		return nil, fmt.Errorf(lus.ErrorIdentityExists, did)
	}

	var issuedTime, expiresTime, attrs = "", "", model.Attrs{}

	// getParticipant certificate attrs
	if request.CertPem != "" {
		// validate cert
		certX509, err := lus.GetX509CertFromPem(request.CertPem)
		if err != nil {
			return nil, err
		}
		err = lus.HasExpired(certX509)
		if err != nil {
			return nil, err
		}
		// get dates
		dateCert := lus.GetDateCertificate(certX509)
		issuedTime = dateCert["issuedTime"]
		expiresTime = dateCert["expiresTime"]

		// get attrs
		attrs = modeltools.GetAttrsCert(certX509)

		// validating publicKey
		certPublicKey, err := lus.GetPublicKey(certX509)
		if err != nil {
			return nil, err
		}
		if strings.Compare(certPublicKey, publicKey) != 0 {
			return nil, fmt.Errorf("public key parameter does not match the one obtained from the certificate")
		}
	}

	// timestamp when the transaction was created, have the same value across all endorsers
	txTimestamp, err := lus.GetTxTimestampRFC3339(ctx.GetStub())
	if err != nil {
		return nil, err
	}

	if request.Roles == nil {
		// Use make to create an empty slice of string.
		request.Roles = make([]string, 0)
	}

	// Create Participant
	identity := model.Participant{
		DocType:     ParticipantDocType,
		Did:         did,
		PublicKey:   publicKey,
		IssuerID:    request.IssuerID,
		Creator:     "",
		Roles:       request.Roles,
		Attrs:       attrs,
		AttrsExtras: make(map[string]string),
		Time:        txTimestamp,
		IssuedTime:  issuedTime,
		ExpiresTime: expiresTime,
		Active:      true,
		MspID:       clientMSPID,
	}
	// compositeKey ID
	compositeKeyID, err := ctx.GetStub().CreateCompositeKey(ParticipantDocType, []string{identity.Did})
	if err != nil {
		return nil, err
	}

	// JSON encoding of identity
	identityEncode, _ := json.Marshal(identity)
	if err := ctx.GetStub().PutState(compositeKeyID, identityEncode); err != nil {
		return nil, fmt.Errorf("failed to create identity: %v", err)
	}

	return &model.ParticipantResponse{
		DID:     identity.Did,
		Roles:   identity.Roles,
		Creator: nil,
	}, nil
}

// DeleteParticipant
// TODO: debug
func (ci *ContractIdentity) DeleteParticipant(ctx contractapi.TransactionContextInterface, identityRequest model.ParticipantDeleteRequest) error {
	log.Printf("[%s][DeleteParticipant]", ctx.GetStub().GetChannelID())
	// check if client-node connected as admin
	if err := lus.AssertAdmin(ctx); err != nil {
		return fmt.Errorf(err.Error())
	}

	// Get the MSP ID of submitting client identity
	clientMSPID, err := ctx.GetClientIdentity().GetMSPID()
	if err != nil {
		return fmt.Errorf(lus.ErrorGetMSPID, err)
	}

	// get user
	userToRevoke, err := ci.GetParticipant(ctx, model.ParticipantGetRequest{Did: identityRequest.UserDid})
	if err != nil {
		return fmt.Errorf("failed to get participant identity: %v", err)
	}
	if userToRevoke == nil {
		return fmt.Errorf(lus.ErrorDefaultNotExist, identityRequest.UserDid)
	}

	if userToRevoke.MspID != clientMSPID {
		return fmt.Errorf("client from org %v is not authorized to delete data from an identity generated by the org %v", clientMSPID, userToRevoke.MspID)
	}

	var callerID = userToRevoke.Did
	// if not the participant himself then we get his ID
	if identityRequest.UserDid != identityRequest.CallerDid {
		// get caller
		callerParticipant, err := ci.GetParticipant(ctx, model.ParticipantGetRequest{Did: identityRequest.UserDid})
		if err != nil {
			return fmt.Errorf("failed to get caller identity: %v", err)
		} else if callerParticipant == nil {
			return fmt.Errorf(lus.ErrorDefaultNotExist, identityRequest.CallerDid)
		}
		callerID = callerParticipant.Did
	}

	// participant composite KEY
	participantKey, err := ctx.GetStub().CreateCompositeKey(ParticipantDocType, []string{userToRevoke.Did})
	if err != nil {
		return err
	}

	err = ctx.GetStub().DelState(participantKey)
	if err != nil {
		return fmt.Errorf("failed to delete identity %s: %v", userToRevoke.Did, err)
	}

	// index
	deletedKey, err := ctx.GetStub().CreateCompositeKey(ObjectTypeParticipantDeleted, []string{Deleted, userToRevoke.Did})
	if err != nil {
		return err
	}

	// timestamp when the transaction was created, have the same value across all endorsers
	txTimestamp, err := lus.GetTxTimestampRFC3339(ctx.GetStub())
	if err != nil {
		return err
	}

	payload := &model.ParticipantDeletedPayload{
		MspID:    clientMSPID,
		Time:     txTimestamp,
		CallerID: callerID, // keep a record of the user who deleted the identity
	}
	// JSON encoding of payload
	payloadJE, _ := json.Marshal(payload)

	if err := ctx.GetStub().PutState(deletedKey, payloadJE); err != nil {
		return fmt.Errorf("could not create deleted index %v: %v", deletedKey, err)
	}
	return err
}

func (ci *ContractIdentity) UpdateParticipant(ctx contractapi.TransactionContextInterface, request model.ParticipantUpdateRequest) error {
	log.Printf("[%s][UpdateParticipant]", ctx.GetStub().GetChannelID())

	// check if client-node connected as admin
	if err := lus.AssertAdmin(ctx); err != nil {
		return err
	}

	did := request.DID
	if config.AutogenerateDid {} else if request.DID == "" {
		return fmt.Errorf(lus.ErrorRequiredParameter, "did")
	}

	identity, err := ci.GetParticipant(ctx, model.ParticipantGetRequest{Did: did})
	if err != nil {
		return err
	} else if identity == nil {
		return fmt.Errorf(lus.ErrorDefaultNotExist, did)
	}

	// compositeKey ID
	compositeKeyID, err := ctx.GetStub().CreateCompositeKey(ParticipantDocType, []string{did})
	if err != nil {
		return err
	}

	valueToUpdate, err := lus.UpdateJSON(request, identity)
	if err != nil {
		return err
	}
	if err := ctx.GetStub().PutState(compositeKeyID, valueToUpdate); err != nil {
		return fmt.Errorf(lus.ErrorUpdateIdentity, compositeKeyID)
	}

	return nil
}


func (ci *ContractIdentity) GetParticipant(ctx contractapi.TransactionContextInterface, request model.ParticipantGetRequest) (*model.Participant, error) {
	log.Printf("[%s][GetParticipant]", ctx.GetStub().GetChannelID())

	participant, err := ci.getParticipant(ctx, request.Did)
	if err != nil {
		return nil, err
	}

	var identity model.Participant
	err = json.Unmarshal(participant, &identity)
	if err != nil {
		return nil, err
	}

	return &identity, nil
}

// GetParticipantHistory returns the chain of custody for an identity since issuance
//
// Arguments:
//		0: model_api.ParticipantGetRequest
// Returns:
//		0: []model_api.ParticipantHistoryQueryResponse
//		1: error
func (ci *ContractIdentity) GetParticipantHistory(ctx contractapi.TransactionContextInterface, request model.ParticipantGetRequest) ([]model.ParticipantHistoryQueryResponse, error) {
	log.Printf("GetParticipantHistory: ID %v", request.Did)

	identity, err := ci.GetParticipant(ctx, model.ParticipantGetRequest{Did: request.Did})
	if err != nil {
		return nil, err
	} else if identity == nil {
		return nil, fmt.Errorf(lus.ErrorDefaultNotExist, request.Did)
	}

	// compositeKey ID
	compositeKeyID, err := ctx.GetStub().CreateCompositeKey(ParticipantDocType, []string{identity.Did})
	if err != nil {
		return nil, err
	}
	resultsIterator, err := ctx.GetStub().GetHistoryForKey(compositeKeyID)
	if err != nil {
		return nil, err
	}
	defer resultsIterator.Close()

	var records []model.ParticipantHistoryQueryResponse
	for resultsIterator.HasNext() {
		response, err := resultsIterator.Next()
		if err != nil {
			return nil, err
		}

		identity := model.ParticipantQueryResponse{}
		identity.ParticipantID = request.Did
		if len(response.Value) > 0 {
			err = json.Unmarshal(response.Value, &identity)
			if err != nil {
				return nil, err
			}
		}

		timestamp := modeltools.GetTimestampRFC3339(response.Timestamp)

		record := model.ParticipantHistoryQueryResponse{
			TxID:     response.TxId,
			Time:     timestamp,
			Record:   &identity,
			IsDelete: response.IsDelete,
		}
		records = append(records, record)
	}

	return records, nil
}

// GetParticipants get all identity
//
// Arguments:
//		0: request model.RichQuerySelector
// Returns:
//		0: *model.PaginatedQueryResponse
//		1: error
func (ci *ContractIdentity) GetParticipants(ctx contractapi.TransactionContextInterface, request model.QueryPaginator) (*model.PaginatedQueryResponse, error) {
	log.Printf("[%s][GetParticipants]", ctx.GetStub().GetChannelID())

	resultsIterator, responseMetadata, err := ctx.GetStub().GetStateByPartialCompositeKeyWithPagination(ParticipantDocType, []string{}, int32(request.PageSize), request.Bookmark)
	if err != nil {
		return nil, err
	}
	defer resultsIterator.Close()

	var items = make([]interface{}, 0)
	for resultsIterator.HasNext() {
		responseRange, err := resultsIterator.Next()
		if responseRange == nil {
			return nil, err
		}

		var identity model.ParticipantResponse
		err = json.Unmarshal(responseRange.Value, &identity)
		if err != nil {
			return nil, err
		}
		items = append(items, identity)
	}

	return &model.PaginatedQueryResponse{
		Records:             items,
		FetchedRecordsCount: responseMetadata.FetchedRecordsCount,
		Bookmark:            responseMetadata.Bookmark,
	}, nil
}

// ParticipantExits returns true when identity with given key exists in the worldState.
func (ci *ContractIdentity) ParticipantExits(ctx contractapi.TransactionContextInterface, request model.ParticipantGetRequest) (bool, error) {
	log.Printf("[%s][ParticipantExits]", ctx.GetStub().GetChannelID())
	identityResultsIterator, err := ctx.GetStub().GetStateByPartialCompositeKey(ParticipantDocType, []string{request.Did})
	if err != nil {
		return false, fmt.Errorf("failed to read identity %s from world state. %v", request.Did, err)
	}
	defer identityResultsIterator.Close()

	return identityResultsIterator.HasNext(), nil
}

func (ci *ContractIdentity) getParticipant(ctx contractapi.TransactionContextInterface, did string) ([]byte, error) {
	log.Printf("[%s][getParticipant]", ctx.GetStub().GetChannelID())
	// compositeKey ID
	compositeKeyID, err := ctx.GetStub().CreateCompositeKey(ParticipantDocType, []string{did})
	if err != nil {
		return nil, err
	}

	identityBytes, err := ctx.GetStub().GetState(compositeKeyID)
	if err != nil {
		return nil, fmt.Errorf(lus.ErrorGetIdentity, compositeKeyID)
	} else if identityBytes == nil {
		return nil, fmt.Errorf(lus.ErrorDefaultNotExist, compositeKeyID)
	}

	return identityBytes, nil
}